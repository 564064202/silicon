
The Silicon Web Framework
=================================


Silicon is a easy to use, fast, safe, modern C++ remote procedure call framework
based on the C++14 standard. It relies the powerful new
features of C++ and imitate the flexibility of other languages like
Ruby, Python, Go or Javascript.

Features
=========================

  - Ease of use:

    The framework is designed so that the user only write the core of
    the procedures, the framework take care of the rest
    (serialization, generation of client libraries, routing, ...)

  - Fast:
    
    Thanks to C++, no interpreter, no virtual maching, just assembly
    generated by the compiler.

  - Safe (almost):

    At least safer than any interpreted language. The use of static
    C++ meta programming helps the compiler to verify the consistency
    of the code.

  - Automatic serialization and deserialization of the messages:

    Thanks to static introspection and meta programming, a json parser
    and encoder is generated for each message. No hash table and other
    dynamic structures as in all other json frameworks.

  - Automatic generation of the client libraries:

    Again, thanks to static introspection, the framework generates at
    compile time the client libraries. As of today, only javascript is
    supported.

  - Dependency Injection at compile time.    

  - O(1) routage:

    Unlike in classical web apps, the generated client libraries are
    aware of the position of each procedure in the server index, so
    routing can be done using this index instead of a string.


Getting Started
=========================

The most basic procedure is not even a function, but directly the
string to write back in the http response body:

```c++
namespace sl = silicon
int main(int argc, char* argv[])
{
  sl::server s(argc, argv);

  // Create the Hello world procedure.
  s["hello_world"] = std::string("Hello world!");
  // ^^^^^^^^^^^ -> This will be the name of the procedure in the client libraries
  //                (see below the javascript example).

  // Generate the javascript client libraries and serve it on a specific route.
  s["/bindings.js"] = generate_javascript_bindings(s, sl::module = "hello_world_api");
 
  s.serve();
}
```

The javascript client would be:

```javascript
<script type="text/javascript" src="http://my_server_path/bindings.js" />

<script>
        hello_world_api.hello_world().then(function(r){ document.write(r); });
</script>
```

Silicon also takes procedures as functions:

```c++

  // A lambda function returning the string to send.
  s["lambda1"] = [] () { return "Hello from lambda"; };

  // Or an staticaly introspectable object from the iod library (see the doc)
  // The serialization to json is automatic.
  s["lambda2"] = [] () { return iod::D(name = "Paul", city = "Paris"); };

  // A procedure taking parameters.
  // The type of the parameter must be specified with iod::D.
  s["lambda3"] = [] (decltype(D(name = std::string())) params)
  { 
    return "Hello" + params.name; 
  };

  // A function taking the response object, for example to set the response headers.
  s["lambda2"] = [] () {
     return iod::D(name = "Paul", city = "Paris");
  };

```
